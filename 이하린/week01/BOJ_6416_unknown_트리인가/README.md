`트리` 

<h3> 백준 6416번 ? 트리인가? 문제 </h3>

💻 메모리 : `17604KB`</br>

⏲️ 시간 : `220ms`

<hr>

<h3> 문제 조건 </h3>

**트리 조건**
- 들어오는 간선이 하나도 없는 단 하나의 노드 존재, 이를 루트 노드라고 부름
- 루트 노드를 제외한 모든 노드는 반드시 단 하나의 들어오는 간선 존재
- 루트에서 다른 노드로 가는 경로는 반드시 가능하며, 유일. 이는 루트를 제외한 모든 노드에 성립해야한다.

**주의** 트리를 만족하는 자료 구조는 비어 있어도(노드 개수 0개) 트리이다.

<br>

<h3> 풀이 과정 </h3>

 👀 첫 번째 풀 때
 - 루트 노드를 제외한 모든 노드는 반드시 단 하나의 들어오는 간선이 존재한다고 했음
  - u, v를 입력받아 맵에 v를 키로 저장함 (그러면 들어오는 간선이 여러 개 인것을 확인할 수 있을거라고 생각)
  - 만약 `tree.contatinsKey(v)` 라면 `isTree=false` 처리하고 break; 를 통해 while 반복문을 빠져나가도록 구현
    - `tree.containsKey(v)`가 false라면 `tree.put(v,u)` 처리
 
 - 근데 이때 루트 노드의 개수가 1개임을 파악하는 방법이 떠오르지 않았음 ... 
   - 그래서 한 16% 정도에 틀렸습니다. 라고 계속 떴다 ...
 
 <br>
 
 
 👀 두 번째 풀 때
 - 루트 노드를 찾기 위한 방법 생각
   - 현재 맵 구조 `맵<키:v, 값:u>` 이 구조로 루트 노드의 개수를 셀 수 있는 방법을 아무리 생각해도 모르겠어서 들어오는 간선의 개수를 세는 맵을 만드는 방법으로 코드를 다시 짰다.
   - 새로 생성한 맵 구조 `맵<키:u or v(어짜피 노드인 것 같으니까), 값 : 들어오는 노드 개수>` 
 - 새로 생성한 맵으로 코드를 짜니까 루트 노드의 개수를 찾기가 가능했다.
  
 <br>
 
  👀 세 번째 풀 때
  - 트리가 비어있어도 트리 만족
    - 위에 방법으로 코드 짜니까 예시도 다 맞고 임의로 만든 테스트케이스도 다 맞다고 떴는데 계속 틀렸습니다 라고 떴다 ...
    - 트리가 비어있을 때도 트리임을 명시하는 코드가 없어서 그랬던 것
    -  `edge.isEmpty()`가 true이면 `isTree=true`로 설정해주었다. 통과!!
  
  
  <h3> 풀면서 수정한 점들 ... </h3>
  
  - BufferedReader -> Scanner
    - BufferedReader 로 입력받은 수를 가공하니까 제대로 수가 저장되지 않았다 .. BR로도 풀 수 있었겠지만 수를 가공하는데 계속 이상하게 처리가 되었음 .. 
    - 그래서 Scanner로 바꿔서 문제를 풀었습니다!!
  
