#<h1> 문제 </h1>

모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현될 수 있다.

자연수 n이 주어졌을 떄, n을 최소 개수의 제곱수 합으로 표현하는 프로그램을 작성하라!



#<h1> 문제 접근 </h1>

#<h2> 1. 완전탐색 </h2>

DP인거 생각 안 하고 그냥 풀어보려고

for문, 재귀함수 둘 다 해봤다.

질문 게시판 보니까 완탐 돌리려해도 완탐이 잘 안됨..

그냥 DP로 풀기로 했다.

(사실 DP 잘 기억이 안나서 문제만 보고 DP로 풀어야겠다는 생각은 못했다 ㅠㅠ)


#<h2> 2. DP </h2>

DP는 표 형식으로 생각하면 쉽다.

재귀함수처럼 큰 문제를 작은 문제로 쪼개서 해결하고, 그걸 이용해서 마지막 결과를 구한다.

재귀와 비슷한 느낌이지만, 일반적인 재귀는 단순히 사용하면 동일한 작은 계산들이 여러 번 반복되어 계산적으로 비효율적일 수 있다.

하지만 동적 계획법은 작은 문제를 해결한 내용들을 '표' 형식으로 '저장'하였다가 이를 이용하여 큰 문제를 해결한다.

고로, 작은 연산을 다시 수행하지 않아도 된다! 그래서 훨씬 빠르다!


#<h3><동적 계획법 과정></h3>

1. 구성 식 세우기
2. 기저조건 확인
3. 중간 계산 결과를 저장할 수 있는 Table (2차원 또는 3차원)

0. DP?

DP인 걸 생각하지 않고 이 문제를 보면 DP인 걸 잘 모를 수 있다.

그러면 이 문제를 DP로 풀 수 있는 이유가 뭘까?

예시로 나와있는 걸 예로 들면,

1563 = 125^2 + 6^2 + 1^2 + 1^2

이렇게 모든 자연수는 넷 혹은 그 이하의 제곱수의 '합'으로 표현될 수 있다.

그리고 우리가 구하고 싶은 것은 입력받은 자연수가 '몇 개'의 제곱수의 합으로 표현될 수 있는지 이다.

따라서 우리는 다음과 같은 표를 이용해서 DP로 이 문제를 해결할 수 있따.


#<h3><풀이></h3>

여기서는 1차원 배열의 table이 필요하다.

- i : 1~num까지의 숫자

- dp[i] : 숫자 i가 몇 개의 제곱수로 표현되어 있는가

이중 for문을 통해서 i를 1~num까지 증가시키고(표 채우기 위해서),

각 i마다 j를 1부터 sqrt(i)까지 증가시키며(제곱을 했을 때 i를 만들 수 있는 경우의 수)

dp[i]에 min(dp[i], dp[i - doubleJ] + 1)을 대입한다.

dp[i - doubleJ]를 통해서, 이전에 구해 두었던 제곱값의 수를 이용할 수 있고,

이를 통해 자잘한 실행 시간을 단축시킬 수 있다.

